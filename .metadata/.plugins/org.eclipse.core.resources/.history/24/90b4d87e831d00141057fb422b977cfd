/**
 * Copyright 2014  XCL-Charts
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 	
 * @Project XCL-Charts 
 * @Description Android图表基类库
 * @author XiongChuanLiang<br/>(xcl_168@aliyun.com)
 * @license http://www.apache.org/licenses/  Apache v2 License
 * @version 1.3
 */
package org.xclcharts.renderer.plot;

import org.xclcharts.common.MathHelper;

import android.graphics.Canvas;
import android.graphics.Path;


/**
 * @ClassName PointerRender
 * @Description 指针绘制类
 * @author XiongChuanLiang<br/>(xcl_168@aliyun.com)
 * 
 */

public class PointerRender extends Pointer{
	
	private static final int FIX_ANGLE = 90;
	
	protected float mStartAngle = 0.0f;
	protected float mTotalAngle = 0.0f;
	protected float mPointerAngle = 0.0f;
	
	protected float mParentRadius = 0.0f;
	private float mPointerRadius = 0.0f;
	
	
	public PointerRender()
	{		
	}
	
	
	public void setCurrentAngle(float currentAngle)
	{	
		mPointerAngle = currentAngle;
	}
	
	public void setStartAngle(float startAngle)
	{	
		mStartAngle = startAngle;
	}
	
	public void setTotalAngle(float totalAngle)
	{		
		mTotalAngle = totalAngle;
	}
	
	public void setParentRadius(float radius)
	{
		mParentRadius = radius;
		// float currentRadius = mul(this.getRadius() ,mPointerRadiusPercentage); 
	}
	
	
	private void calcRadius()
	{
		mPointerRadius = MathHelper.getInstance().mul(mParentRadius ,mPointerRadiusPercentage); 
	}
	
	public void setPointEndXY(float x,float y)
	{
		mEndX = x;
		mEndY = y;
	}
			
	public boolean isChangedStartXY()
	{
		if(Float.compare(mCenterX, 0.0f) == 0 && Float.compare(mCenterY, 0.0f) == 0)
		{
			return false;
		}else{
			return true;
		}
	}
	
	public boolean isChangedAngle() 
	{
		if(Float.compare(mPointerAngle, 0.0f) == 0)
		{
			return false;
		}else{
			return true;
		}
	}
	
	public boolean isChangedPercentage() 
	{
		if(Float.compare(mPercentage, 0.0f) == 0)
		{
			return false;
		}else{
			return true;
		}
	}
		
	public float getCurrentPointerAngle()
	{	
		mPointerAngle = MathHelper.getInstance().mul( mTotalAngle , mPercentage);
		return mPointerAngle;
	}
	
	private void calcEndXY()
	{		
		float currentRadius = MathHelper.getInstance().mul(mPointerRadius ,mPointerRadiusPercentage); 		
		MathHelper.getInstance().calcArcEndPointXY(mCenterX, mCenterY, currentRadius,
										MathHelper.getInstance().add(getCurrentPointerAngle() , mStartAngle));	
		mEndX = MathHelper.getInstance().getPosX();
		mEndY = MathHelper.getInstance().getPosY();			
	}
	
	
	
	public void renerLine(Canvas canvas)
	{
		canvas.drawLine(mCenterX, mCenterY, mEndX,mEndY, getPointerPaint());   
	}
	
	public void renderTriangle(Canvas canvas)
	{
		    float currentAgent1 = MathHelper.getInstance().add(mPointerAngle - FIX_ANGLE, mStartAngle);
		    float currentAgent2 = MathHelper.getInstance().add(mPointerAngle + FIX_ANGLE, mStartAngle);
		    		    	        
	        float bX = 0.0f,bY = 0.0f,eX = 0.0f,eY=0.0f;
			MathHelper.getInstance().calcArcEndPointXY(mCenterX, mCenterY, mBaseRadius,currentAgent1);	
			bX = MathHelper.getInstance().getPosX();
			bY = MathHelper.getInstance().getPosY();	
	    
	        MathHelper.getInstance().calcArcEndPointXY(mCenterX, mCenterY, mBaseRadius,currentAgent2);	
	        eX = MathHelper.getInstance().getPosX();
	        eY = MathHelper.getInstance().getPosY();	
	    
	        Path path = new Path();
	        path.moveTo(mEndX, mEndY);
	        path.lineTo(bX, bY);
	        path.lineTo(eX, eY);
	        path.close();
	        canvas.drawPath(path, getPointerPaint());	  	        	        
	}
	
	public void renderCircle(Canvas canvas)
	{
		canvas.drawCircle(mCenterX, mCenterY, mBaseRadius, getPaintBaseCircle());
	}
	
	public void render(Canvas canvas)
	{
		calcRadius();
		calcEndXY();
		switch(mPointStyle)
		{
			case TRIANGLE:
				renderTriangle(canvas);
				if(mShowBase)renderCircle(canvas);
				break;
			case LINE:
				renerLine(canvas);
				if(mShowBase)renderCircle(canvas);
				break;
			default:
				break;
		}
	}
}
