/**
 * Copyright 2014  XCL-Charts
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 	
 * @Project XCL-Charts 
 * @Description Android图表基类库
 * @author XiongChuanLiang<br/>(xcl_168@aliyun.com)
 * @license http://www.apache.org/licenses/  Apache v2 License
 * @version 1.0
 */
package org.xclcharts.chart;


import java.util.ArrayList;
import java.util.List;

import org.xclcharts.common.CurveHelper;
import org.xclcharts.common.MathHelper;
import org.xclcharts.renderer.LnChart;
import org.xclcharts.renderer.XEnum;
import org.xclcharts.renderer.line.PlotDot;
import org.xclcharts.renderer.line.PlotDotRender;
import org.xclcharts.renderer.line.PlotLine;

import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Align;
import android.graphics.Paint.Style;
import android.graphics.Path;
import android.graphics.PointF;
import android.graphics.RectF;
import android.util.Log;


/**
 * @ClassName AreaChart
 * @Description  面积图基类
 * @author XiongChuanLiang<br/>(xcl_168@aliyun.com)
 */

public class AreaChart extends LnChart{	
	
	private static final String TAG="AreaChart";
	
	//画点分类的画笔
  	protected Paint mPaintAreaFill =  null; 
  	
    //数据源
  	protected List<AreaData> mDataset;
  	
  	//透明度
  	private int mAreaAlpha = 100;  	
  
	
	public AreaChart()
	{
		super();
		
		mPaintAreaFill = new Paint();
		mPaintAreaFill.setStyle(Style.FILL);
		mPaintAreaFill.setAntiAlias(true);
		mPaintAreaFill.setColor((int)Color.rgb(73, 172, 72));		
		
		categoryAxis.setHorizontalTickAlign(Align.CENTER);
		dataAxis.setHorizontalTickAlign(Align.LEFT);		
	}
		
				
	 /**
	 * 分类轴的数据源
	 * @param categories 分类集
	 */
	public void setCategories(final List<String> categories)
	{		
		categoryAxis.setDataBuilding(categories);
	}
	
	/**
	 *  设置数据轴的数据源
	 * @param dataset 数据源
	 */
	public void setDataSource(final List<AreaData> dataset)
	{		
		if(null != mDataset) mDataset.clear();
		this.mDataset = dataset;		
	}
	
	/**
	 * 设置透明度,默认为100
	 * @param alpha 透明度
	 */
	public void setAreaAlpha(int alpha)
	{
		mAreaAlpha = alpha;
	}	


	private boolean calcAllPoints(AreaData bd,
			List<RectF> lstDots,
			List<PointF> lstPoints,
			List<PointF> lstPathPoints)
	{
		//数据源
		List<Double> chartValues = bd.getLinePoint();
		if(null == chartValues)
		{
			Log.e(TAG,"线数据集合为空.");
			return false;
		}				
				
		float initX =  plotArea.getLeft();
        float initY =  plotArea.getBottom();
         
		float lineStartX = initX;
        float lineStartY = initY;
        float lineEndX = 0.0f;   
        float lineEndY = 0.0f;   
        						
		float axisScreenHeight = getAxisScreenHeight();
		float axisDataHeight =  (float) dataAxis.getAxisRange();	
		float currLablesSteps = div(getAxisScreenWidth(), 
										(categoryAxis.getDataSet().size() -1));
				
		//path area
		lstPathPoints.add( new PointF(initX,initY));
		
            
        double dper = 0d;
		int j = 0;	 
		for(Double bv : chartValues)
        {								
			//参数值与最大值的比例  照搬到 y轴高度与矩形高度的比例上来 	                                
        	//float valuePosition = (float) Math.round(
			//		axisScreenHeight * ( (bv - dataAxis.getAxisMin() ) / axisDataHeight)) ;        	            
        	dper = MathHelper.getInstance().sub(bv, dataAxis.getAxisMin());
        	float valuePosition = mul(axisScreenHeight, div(dtof(dper),axisDataHeight) );
        	
        	if(j == 0 )
			{
				lineStartX = initX;
				lineStartY = sub(initY , valuePosition);
				
				lineEndX = lineStartX ;
				lineEndY = lineStartY;	
			}else{
				lineEndX = add(initX , (j) * currLablesSteps);
				lineEndY = sub(initY , valuePosition);
			}        
        	
        	if(0 == j )
    		{
        		//line
        		lstPoints.add( new PointF(lineStartX,lineStartY));
        		lstPoints.add( new PointF(lineEndX,lineEndY));
    			
        		//path area
        		lstPathPoints.add( new PointF(lineStartX,lineStartY));
        		lstPathPoints.add( new PointF(lineEndX,lineEndY));
    		}else{     
    			//line
    			lstPoints.add( new PointF(lineEndX,lineEndY));
    			//path area
    			lstPathPoints.add( new PointF(lineEndX,lineEndY));
    		}            		
    
        	//dot
        	lstDots.add(new RectF(lineStartX,lineStartY,lineEndX,lineEndY));
   	
        	lineStartX = lineEndX;
			lineStartY = lineEndY;
			j++;
        }	
		
		//path area
		lstPathPoints.add( new PointF(lineStartX ,lineStartY));
		lstPathPoints.add( new PointF(lineStartX ,initY));
		return true;        
	}
	
	private boolean renderArea(Canvas canvas,Paint paintAreaFill,Path pathArea,
								AreaData areaData,
								List<PointF> lstPathPoints)
	{		        		
		for(int i = 0;i<lstPathPoints.size();i++)
		{
			PointF point = lstPathPoints.get(i);
        	if(0 == i)
        	{
        		pathArea.moveTo(point.x ,point.y);  
        	}else{
        		pathArea.lineTo(point.x ,point.y);   
        	}				
		}							
		pathArea.close();
	
        //设置当前填充色
		paintAreaFill.setColor(areaData.getAreaFillColor());	
		//绘制area
	    canvas.drawPath(pathArea, paintAreaFill);	      
	    pathArea.reset();		
		return true;
	}
	

	private boolean renderBezierArea(Canvas canvas, Paint paintAreaFill,Path bezierPath,
										AreaData areaData,
										List<PointF> lstPathPoints)
	{		        		
		
		PointF[] bezierControls = new PointF[2];			
		if(null == bezierPath)bezierPath = new Path();
		
		float initX =  plotArea.getLeft();
        float initY =  plotArea.getBottom();
		bezierPath.moveTo(initX, initY);
		
		
		for(int i = 0;i<lstPathPoints.size();i++)
		{
			if(i<3) continue;
			
			CurveHelper.curve3( lstPathPoints.get(i-2),  
					lstPathPoints.get(i-1), 
					lstPathPoints.get(i-3),
					lstPathPoints.get(i), 
					bezierControls);
			
			bezierPath.cubicTo( bezierControls[0].x, bezierControls[0].y, 
					bezierControls[1].x, bezierControls[1].y, 
					lstPathPoints.get(i -1 ).x, lstPathPoints.get(i -1 ).y);		
		}			
	
	
		if(lstPathPoints.size()> 3)
		{			
			PointF stop  = lstPathPoints.get(lstPathPoints.size()-1);
			//PointF start = lstPathPoints.get(lstPathPoints.size()-2);						
			CurveHelper.curve3(lstPathPoints.get(lstPathPoints.size()-2),  
										stop, 
										lstPathPoints.get(lstPathPoints.size()-3),
										stop, 
										bezierControls);
			bezierPath.cubicTo( bezierControls[0].x, bezierControls[0].y, 
					bezierControls[1].x, bezierControls[1].y, 
					lstPathPoints.get(lstPathPoints.size() -1 ).x, 
					lstPathPoints.get(lstPathPoints.size() -1 ).y);							
		}							
		bezierPath.close();
						
        //设置当前填充色
		paintAreaFill.setColor(areaData.getAreaFillColor());	        	       
	    canvas.drawPath(bezierPath, paintAreaFill);		
	    bezierPath.reset();
		return true;
	}
	
	
	private boolean renderLine(Canvas canvas, AreaData areaData,
								List<PointF> lstPoints)
	{		        
		for(int i=0;i<lstPoints.size();i++)
        {	        	
        	if(0 == i)continue;
        	PointF pointStart = lstPoints.get(i - 1);
        	PointF pointStop = lstPoints.get(i);
        	            
  	        canvas.drawLine( pointStart.x ,pointStart.y ,pointStop.x ,pointStop.y,
  	    		  			areaData.getLinePaint()); 	
        }
		return true;
	}
	
	
	private boolean renderBezierCurveLine(Canvas canvas,Path bezierPath,
											AreaData areaData,List<PointF> lstPoints)
	{		        		
		renderBezierCurveLine(canvas,areaData.getLinePaint(),bezierPath,lstPoints); 		 
		return true;
	}

	/**
	 * 绘制区域
	 * @param bd	数据序列
	 * @param type	绘制类型
	 * @param alpha 透明度
	 */
	private boolean renderDotAndLabel(Canvas canvas, AreaData bd,int dataID,
										List<RectF> lstDots)
	{
		
		 PlotLine pLine = bd.getPlotLine();
		 if(pLine.getDotStyle().equals(XEnum.DotStyle.HIDE) == true 
				 					||bd.getLabelVisible() == false )
		 {
    	   return true;
		 }
		 int childID = 0;

		//数据源
		List<Double> chartValues = bd.getLinePoint();
		if(null == chartValues)
		{
			Log.e(TAG,"线数据集合为空.");
			return false;
		}	
		
		for(int i=0;i<lstDots.size();i++)
		{
			Double dv = chartValues.get(i);
			
			RectF  dot = lstDots.get(i);
			
			if(!pLine.getDotStyle().equals(XEnum.DotStyle.HIDE))
        	{            	
        		PlotDot pDot = pLine.getPlotDot();	              
        		float rendEndX  = add(dot.right  , pDot.getDotRadius());    
        		            	      
        		RectF rect = PlotDotRender.getInstance().renderDot(canvas,pDot,
        				dot.left ,dot.top ,
        				dot.right ,dot.bottom,
        				pLine.getDotPaint()); //标识图形            			                	
        		dot.right = rendEndX;
    			this.savePointRecord(dataID,childID,dot.right ,dot.bottom,rect);  
    			childID++;
        	}
    		
    		if(bd.getLabelVisible())
        	{        			            		
        		canvas.drawText(this.getFormatterItemLabel(dv) ,
        				dot.right ,dot.bottom,  pLine.getDotLabelPaint());
        	} 
		}

		return true;
	}	

	
	
	private boolean renderVerticalPlot(Canvas canvas)
	{								
		if(null == mDataset)
		{
			Log.e(TAG,"数据源为空.");
			return false;
		}
		
		renderVerticalDataAxis(canvas);
		renderVerticalCategoryAxis(canvas);
		
		//path area
		List<PointF> lstPathPoints =new ArrayList<PointF>(); 
		Path pathArea = new Path();
		
		//key
		List<LnData> lstKey = new ArrayList<LnData>();	
		
		//line
		List<PointF> lstPoints = new ArrayList<PointF>();	
		
		//dots
		List<RectF> lstDots =new ArrayList<RectF>();
								
		//透明度。其取值范围是0---255,数值越小，越透明，颜色上表现越淡             
		mPaintAreaFill.setAlpha( mAreaAlpha );  
						
		//开始处 X 轴 即分类轴                  
		for(int i=0;i<mDataset.size();i++)
		{					
			AreaData areaData = mDataset.get(i);
			
			calcAllPoints( areaData,lstDots,lstPoints,lstPathPoints);					
			
			if(getCrurveLineStyle() == XEnum.CrurveLineStyle.BEZIERCURVE)
			{
				renderBezierArea(canvas,mPaintAreaFill,pathArea,areaData,lstPathPoints);
				renderBezierCurveLine(canvas,pathArea,areaData,lstPoints);	
			}else{
				renderArea(canvas,mPaintAreaFill,pathArea,areaData,lstPathPoints);	
				renderLine(canvas,areaData,lstPoints);	
			}
													
			renderDotAndLabel(canvas,areaData,i,lstDots);						
			lstKey.add(areaData);
			
			lstDots.clear();
			lstPoints.clear();
			lstPathPoints.clear();
		}							
		plotLegend.renderLineKey(canvas, lstKey);
		lstKey.clear();
		return true;
	}
			
	@Override
	protected boolean postRender(Canvas canvas) throws Exception 
	{
		// 绘制图表
		try {
			super.postRender(canvas);
			
			//绘制图表
			return renderVerticalPlot(canvas);
		} catch (Exception e) {
			throw e;
		}
	}
	 
}
